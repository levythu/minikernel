# 15-410/605 P3: Operating System Kernel
Leiyu Zhao (leiyuz)
## Highlight Design Decision

### GlobalLock and LocalLock
For the section that we don't want to be interrupted, we differentiate GlobalLock from Locallock. Locallock is implemented simply by disabling and enabling interrupts, while GlobalLock is a superset of LocalLock that also ensures only one CPU core can enter the session. Since inside both lock interrupts are disabled, on single CPU, GlobalLock degrades to LocalLock. However, we differentiate them to make the kernel easier to be scaled out to multicore.

Another interesting design is that those locks are CPU-reentrant, i.e., for the same CPU, a lock can be acquired arbitrary times without any problem or worrying about when should *real* unlock takes place.

Note that GlobalLock is a spinlock. In multicore environment, it's reasonable to spin sometimes, while in single core GlobalLock never spins. Similarly, there're some spinloops on owning a thread, but it's still only for multicore situation. In single core it always succeeds on the first tick.

### Kernel Mutex (kmutex)
GlobalLock/LocalLock is used only for small and critical session that we don't want anything to interrupt. But there're great number of cases where we don't have to be so strict: we allow interleaving with other threads that's unrelated to the critical session. In those cases, we use kmutex, it has very similar semantics to user space mutex, and never disable context switch during the section. For overall prreemptibility, it's a good practice to use kmutex when possible.

Fine-grained lock design makes it easy to ensure interrupt and multithread safety while keeping the best preemptibility.

### MACRO-Generated Syscall Stub, Interrupt Handler and Fault Handler
For those who are registered to IDT, we all use macros to generate codes in very short time, to make it quicker to develop and nicer to look.

## Known Bugs
- In Readline, backspace can remove characters on the screen that does not belong to this round of readline

## Future Refinement
- On print, when there're scrolls, it's slow and therefore improper to be put in synchronous timer event. A better solution is to design 2-phase-print, where the 1st phase only logs things to put and 2nd phase puts them. Then timer synchronous event only does the 1st phase while asynchronous event does the 2nd.
