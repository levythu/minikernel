# 15-410/605 P4: PebPeb - Hypervisor
Leiyu Zhao (leiyuz)

## Hypervisor

Make my own kernel capable of running virtual machines! Current version of hypervisor is able to run `pathos` kernel, and inside the guest kernel, run tests like `nibbles`/`make_crash`/`stack_test`/`mem_eat_test`/etc. (but with much longer run time, and those more complicated tests like `cho` are not run because it takes too long). The hypervisor supports all hypercall specified in the writeup. And all the parts in the writeup are well-supported, like:

- Interrupt forwarding
    - For exception (0~19): forward it immediately to guest
    - For hardware interrupt (32~33): multiplex it by virtual console / the hypervisor in this timeslice
    - For syscalls (65~116, 128~134): forward it immediately to guest
    - According to the writeup, we don't support IDT > 134, however, `pathos` try to register something to it. Our hypervisor treat it as a no-op and print one warning on simics console (so when launching `pathos` you'll find 100+ lines of warnings, that's expected)
- Paging
- Ring0/3 Switching (Mode Switch)

All hypervisor related files are named with prefix `hv-`.

### Interrupt Forwarding

Virtual interrupts are either 1. Immediate interrupt: trap (syscall) or exception (IDT 0~19) or 2. Delayed interrupt: hardware interrupt (keyboard, timer)

To avoid using any locks, we ensure a key condition: **All interrupt deliveries will not interleave**. We ensure this by two ways:
- We only deliver interrupts when it's on its own process space:
    - For immediate interrupts, it's naturally delivered on its own process space
    - For delayed interrupts (generated by hardware), it depends:
        - For timer interrupt, we only try generating virtual timer interrupt to delayed interrupt queue when it's ticked on hypervisor's process, i.e., own timer tick (actually we tick every 2 own timer ticks to let delayed interrupt queue be shorter)
        - For other interrupt, e.g. keyboard, we use multiplexer to multiplex virtual interrupts to all listened hypervisor's delayed interrupt queues.
- We only deliver interrupts when we are only *one-iret* way from guest. (i.e., one iret will go to guest. this is achieved by examine `%cs` on iret stack)
    - For immediate interrupts, it's natrually true
    - For delayed interrupts, we only deliver one from the queue at the end of *one-iret* timer tick.

 This design limits the speed for guest to consume delayed virtual interrupts (every *one-iret* timer tick there can be at most 1 delayed interrupt being consumed). So we cannot generate virtual timer tick too frequent, the interval should be at least one own timer tick.

### Paging

Initially, the paging is off and current page directory is the direct mapping page directory. When paging is turned on, we need to switch to different page directory very often.

Unfortunately, our previous design requires PageDirectory field of PCB to be fixed after creation. So, instead of changing PageDirectory, we keep the page directory header pointer and change its content (by shallow copy) instead.

The original direct mapping page directory is always backuped, because it's needed

- When we need to access the guest physical memory (e.g. access guest PD)
- When we want to know how guest physical memory (i.e. host virtual memory) is mapped to hosy physical memory
- When we are about to exit, so that we must recover original page directory to let Reaper reclaim all user-pages (see reaper.c)

We don't keep a copy of guest page table in kernel memory, instead, we recompile it everytime on 1. change cr3; 2. mode switch.

Except adjustpg, which just changes one mapping, every large-scale mapping mutation (e.g. change cr3, mode switch, temporarily use original page directory) needs flush the whole TLB. To avoid any race with context switcher itself, we deligate it to context switcher. i.e., achieving flushing TLB by forcing a context switch to other threads. And when it switches back after a while, the TLB is flushed. By the means, we eliminate race regarding to changing page directory.

## Virtual console

We have implemented good support for virtual console. And by running `new_shell` you can activate a new shell. Thanks to reasonable former design, all we need to do is to migrate the static global variables from `keyboard_event.c` and `graphic_driver.c` to a struct, and mutate all related functions to have the 1st parameter as the pointer to virtual console struct (in practice, the virtual console number, a.k.a, VCNumber). By the means, our keyboard and video behaviors are **exactly the same** as P3.

[TAB] is the key to switch among virtual consoles (and in simics console it will prints the VCNumber of current virtual console). Forked process will share the same virtual console as the parent. When one virtual console has no process in it (which means there will not be anymore), it prints *WARNING: once you switch, you can NEVER get back to this console!* at that screen, and destroy the console next time it's switched out.

As mentioned, we've changed all internal functions of keyboard and consoles to include the VCNumber as the 1st param. However, `putbyte()` cannot be changed -- 410kern's libc use this to implement printf and we cannot touch it. Although we can always call get current running thread in `putbyte()` to get the correct virtual console, this operation is not cheap and may not be good to appear in such function that may be called hundreds of times to print something. As a workaround, `printf()` in kernel will put strings on currently active virtual console. (But in our kernel, we almost didn't use `printf()`)

### Enriched `misbehave 701` Support

Now, `misbehave 701` will also prints virtual console usage inside the large system status tree. A sample is like:

```
├ Virtual Console List
│ ├ [Console #0] Shared by 4 procs
│ ├ [Console #1] Shared by 2 procs
│ ├ [Console #2] Shared by 61 procs
│ └ Total 3 screens
```
